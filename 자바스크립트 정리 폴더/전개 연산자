// 전개 연산자 (spread Operator)

//const a = [1, 2, 3];

//console.log(a);
//console.log(...a); //위에선 [1, 2, 3]이 나왔는데 얜 1 2 3이 나옴 펼쳐져서
//console.log(1, 2, 3);

//const b = [4, 5, 6];
//만약에 두개 데이터를 병합할떄엔 어떻게 해야할까?
//concat 이라는 매소드를 사용해서 병합가능
//const c = a.concat(b); //[1, 2, 3, 4, 5, 6]
//console.log(c);
//전개가 되는 것을 볼수있음
//const d = [...a, ...b];
//console.log(d); //[1, 2, 3, 4, 5, 6]

// 전개연산자는 첫번째로 배열데이터의 대괄호를 날려줌
// 전개연산자는 배열데이터 외에 객체데이터에도 사용가능

//const a = { x: 1, y: 2 };
//const b = { y: 3, z: 4 };

//const c = Object.assign({}, a, b);
//console.log(c); //{x: 1, y: 3, z: 4}
//y: 2는 왜 없냐 객체데이터에서 속성은 고유하잖아 그래서 같은 기존 y(2)가 새로운 변수 y(3)으로 덮어쓰기 됨.
//const d = { a, b };
//const d = { ...a, ...b };
//console.log(d); //a = { x: 1, y: 2 }, b = { y: 3, z: 4 } 주석처리된 첫번째d변수
//고친후 {x: 1, y: 3, z: 4}

//function fn(x, y, z) {
//console.log(x, y, z);
//}

//fn(1, 2, 3); //1 2 3

//const a = [1, 2, 3];
//fn(a[0], a[1], a[2]); //1 2 3 전개연산자가 없을땐 이렇게 일일이 적어야하지만 알고있다면
//fn(...a); //1 2 3
