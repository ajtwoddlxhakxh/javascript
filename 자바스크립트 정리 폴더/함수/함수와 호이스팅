// **함수 (FUnction)**

// 함수 선언문(declaration)
// function hello() {}

// 함수 표현식(expression)

// const hello = function () {};

//함수 선언문과 함수 표현식은 생김새가 다른게 아니고 호이스팅이라는 개념에서 차이점이 발생함

// 호이스팅

// function hello() {
//   console.log("안녕");
// }

// hello(); //안녕

//만약 함수 hello부분을 잘라서 호출하는 hello();보다 아래에 작성하면 어떨까
//이런식으로

// hello();

// function hello() {
//   console.log("안녕");
// }

// 자 보통 코드는 위에서 부터 아래로 작성 및 해석을 해. 그런데
// 정의된 함수는 더 아랫쪽에 존재함.=> 정의되지않는 함수를 사용을 하는 모습

//이 현상을 "호이스팅 현상" 때문에 발생
//호이스팅이라는 것은 함수가 선언되어져 있는 부분을 코드의 최상단으로 끌어올리는 현상
// 그래서 함수 선언문은 어디에 작성하든지 상관없이 호출이 가능함

// hello();

// const hello = function () {
//   console.log("안녕");
// };

//Uncaught ReferenceError: Cannot access 'hello' before initialization at main.js:672:1
//hello()함수가 호출될때 아직 hello함수가 만들어지기전인데 hello함수를 호출하고 있다는거임
//이렇게 표현식같은 경우에는 호이스팅 현상 XX

// 함수의 표현과 선언은 기본적으로 같은 함수를 만드는 행위지만 서로 호이스팅의 발생 유무 차이가 있다는걸 알아야 함.

//  hello();

//  const world = function hello() {
//   console.log('hi')
//  }

 // main.js:684  Uncaught ReferenceError: hello is not defined
//hello라는 함수는 정의가 되어있지않다.
// 우리가 할당연산자(=)를 통해 함수를 표현식으로 만들게 되면 기명함수라도 기존 이름은 제거되고 새롭게 world라는 이름을 사용해야함.

// 수정해보자

//  const world = function hello() {
//   console.log('hi')
//  }

//  world();

//hi
